"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m={},l=()=>{if(Game.time%100===0)for(const o in Memory.creeps)o in Game.creeps||delete Memory.creeps[o];for(const o in Game.creeps){const s=Game.creeps[o];if(!s.my)continue;const e=s.memory.room||s.room.name;m[e]=m[e]||[],m[e].push(s)}},f=o=>{var t,r;typeof o=="string"&&(o=Game.rooms[o]);const s=(t=m[o.name])!=null?t:[];let e=[],n="";if(s.length<3&&o.energyAvailable>=250&&(e=["work","carry","move","move"],n="basic-worker"),e.length){const i=o.find(FIND_MY_SPAWNS,{filter:a=>!a.spawning});if(i.length){const a=(r=i.pop())==null?void 0:r.spawnCreep(e,[o.name,Game.time,n].filter(Boolean).join(":"),{memory:{room:o.name,role:n}});a===OK?console.log("Spawned a screep!"):console.log("Failed to spawn a screep!",a)}}},c=(o,s)=>{if(o.memory.task){const e=o.room.memory.tasks[o.memory.task].indexOf(o.name);o.room.memory.tasks[o.memory.task][e]=null}o.memory.task=s},y=(o,s)=>{switch(o.transfer(s,RESOURCE_ENERGY)){case ERR_NOT_IN_RANGE:o.moveTo(s);break;case OK:o.store.getUsedCapacity()===0&&c(o);break}},k=(o,s)=>{switch(o.harvest(s)){case ERR_NOT_IN_RANGE:o.moveTo(s);break;case OK:if(o.store.getFreeCapacity()===0){if(!o.room.controller)throw new Error("Creep is full in a room without a controller");c(o,o.room.controller.id)}break}},p=()=>{var o;l();for(const s in Game.rooms){const e=Game.rooms[s];e.memory.tasks||(e.memory.tasks={}),f(e);const n=(o=m[s])!=null?o:[];for(const t of n)if(t.memory.task){const r=Game.getObjectById(t.memory.task);r instanceof Source?k(t,r):r instanceof StructureController&&y(t,r)}for(const t of e.find(FIND_SOURCES_ACTIVE))e.memory.tasks[t.id]||(e.memory.tasks[t.id]=[null,null,null])}};exports.loop=p;
//# sourceMappingURL=my-lib.js.map
