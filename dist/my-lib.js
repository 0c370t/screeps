"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const f={fill:"transparent",opacity:.1,stroke:"#febf2b",strokeWidth:.2,lineStyle:"dashed"},c={reusePath:20,visualizePathStyle:f};Creep.prototype.speak=function(...o){console.log(this.name,...o)};Creep.prototype.goto=function(o,t){if(typeof o=="number"||typeof t=="number")return ERR_INVALID_TARGET;const e=this.moveTo(o,Object.assign({},c,t));return e!==OK?this.moveTo(o,Object.assign({},c,t,{reusePath:2})):e};const i={},k=()=>{if(Game.time%100===0)for(const o in Memory.creeps)o in Game.creeps||delete Memory.creeps[o];for(const o in Game.creeps){const t=Game.creeps[o];if(!t.my)continue;const e=t.memory.room||t.room.name;i[e]=i[e]||[],i[e].push(t)}},y=o=>{var s,a;typeof o=="string"&&(o=Game.rooms[o]);const t=(s=i[o.name])!=null?s:[];let e=[],n="";if(t.length<3)o.energyAvailable>=250&&(e=["work","carry","move","move"],n="basic-worker");else switch(!0){case o.energyAvailable>=500:e=["work","work","carry","carry","move","move","move","move"],n="mid-worker";break}if(e.length){const m=o.find(FIND_MY_SPAWNS,{filter:r=>!r.spawning});if(m.length){const r=(a=m.pop())==null?void 0:a.spawnCreep(e,[o.name,Game.time,n].filter(Boolean).join(":"),{memory:{room:o.name,role:n}});r===OK?console.log("Spawned a screep!"):console.log("Failed to spawn a screep!",r)}}},l=(o,t)=>{var e;if(o.speak("Work Complete"),o.memory.task&&o.memory.task in o.room.memory.tasks){console.log(o.room.memory.tasks[o.memory.task],Object.keys(o.room.memory.tasks),o.memory.task);const n=(e=o.room.memory.tasks[o.memory.task])==null?void 0:e.indexOf(o.name);o.room.memory.tasks[o.memory.task][n]=null}o.memory.task=t},d=o=>{const t=Object.entries(o.room.memory.tasks).reduce((n,[s,a])=>{if(a.indexOf(null)===-1)return n;const m=Game.getObjectById(s);if(!m)return n;const r=PathFinder.search(o.pos,m.pos);return r.cost<n.distance?{targetId:s,distance:r.cost}:n},{targetId:null,distance:Number.MAX_SAFE_INTEGER});if(!t.targetId){o.speak("Bored");return}const e=o.room.memory.tasks[t.targetId].indexOf(null);o.room.memory.tasks[t.targetId][e]=o.name,o.memory.task=t.targetId},u=(o,t)=>{const e=o.transfer(t,RESOURCE_ENERGY,o.store.getUsedCapacity());switch(e){case ERR_NOT_IN_RANGE:o.goto(t);break;case OK:case ERR_NOT_ENOUGH_ENERGY:o.speak(`Depositing (${o.store.getUsedCapacity()} / ${o.store.getCapacity()})`),o.store.getUsedCapacity()===0&&l(o);break;default:o.speak("Unhandled deposit status",e)}},g=(o,t)=>{const e=o.harvest(t);switch(e){case ERR_NOT_IN_RANGE:o.goto(t);break;case OK:if(o.store.getFreeCapacity()===0){if(!o.room.controller)throw new Error("Creep is full in a room without a controller");const n=o.room.find(FIND_MY_SPAWNS,{filter:s=>s.store.getFreeCapacity(RESOURCE_ENERGY)>0});n.length?l(o,n[0].id):l(o,o.room.controller.id)}break;default:o.speak("Unhandled mining case",e);break}},p=()=>{var o;k();for(const t in Game.rooms){const e=Game.rooms[t];e.memory.tasks||(e.memory.tasks={}),y(e);const n=(o=i[t])!=null?o:[];for(const s of n)if(s.memory.task||d(s),s.memory.task){const a=Game.getObjectById(s.memory.task);a instanceof Source?(s.speak("Mining"),g(s,a)):a instanceof StructureStorage||a instanceof StructureController?(s.speak("Depositing"),u(s,a)):s.speak("Broken",a)}for(const s of e.find(FIND_SOURCES_ACTIVE))e.memory.tasks[s.id]||(e.memory.tasks[s.id]=[null,null,null])}};exports.loop=p;
//# sourceMappingURL=my-lib.js.map
