"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});Creep.prototype.speak=function(...o){console.log(this.name,...o)};const i={},c=()=>{if(Game.time%100===0)for(const o in Memory.creeps)o in Game.creeps||delete Memory.creeps[o];for(const o in Game.creeps){const s=Game.creeps[o];if(!s.my)continue;const e=s.memory.room||s.room.name;i[e]=i[e]||[],i[e].push(s)}},k=o=>{var t,n;typeof o=="string"&&(o=Game.rooms[o]);const s=(t=i[o.name])!=null?t:[];let e=[],a="";if(s.length<3&&o.energyAvailable>=250&&(e=["work","carry","move","move"],a="basic-worker"),e.length){const m=o.find(FIND_MY_SPAWNS,{filter:r=>!r.spawning});if(m.length){const r=(n=m.pop())==null?void 0:n.spawnCreep(e,[o.name,Game.time,a].filter(Boolean).join(":"),{memory:{room:o.name,role:a}});r===OK?console.log("Spawned a screep!"):console.log("Failed to spawn a screep!",r)}}},y={fill:"transparent",opacity:.1,stroke:"#febf2b",strokeWidth:.2,lineStyle:"dashed"},f={reusePath:20,visualizePathStyle:y},l=(o,s)=>{var e;if(o.speak("Work Complete"),o.memory.task&&o.memory.task in o.room.memory.tasks){console.log(o.room.memory.tasks[o.memory.task],Object.keys(o.room.memory.tasks),o.memory.task);const a=(e=o.room.memory.tasks[o.memory.task])==null?void 0:e.indexOf(o.name);o.room.memory.tasks[o.memory.task][a]=null}o.memory.task=s},d=o=>{const s=Object.entries(o.room.memory.tasks).reduce((a,[t,n])=>{if(n.indexOf(null)===-1)return a;const m=Game.getObjectById(t);if(!m)return a;const r=PathFinder.search(o.pos,m.pos);return r.cost<a.distance?{targetId:t,distance:r.cost}:a},{targetId:null,distance:Number.MAX_SAFE_INTEGER});if(!s.targetId){o.speak("Bored");return}const e=o.room.memory.tasks[s.targetId].indexOf(null);o.room.memory.tasks[s.targetId][e]=o.name,o.memory.task=s.targetId},u=(o,s)=>{const e=o.transfer(s,RESOURCE_ENERGY);switch(e){case ERR_NOT_IN_RANGE:o.moveTo(s,f);break;case OK:case ERR_NOT_ENOUGH_ENERGY:o.speak(`Depositing (${o.store.getUsedCapacity()} / ${o.store.getCapacity()})`),o.store.getUsedCapacity()===0&&l(o);break;default:o.speak("Unhandled deposit status",e)}},g=(o,s)=>{switch(o.harvest(s)){case ERR_NOT_IN_RANGE:o.moveTo(s,f);break;case OK:if(o.store.getFreeCapacity()===0){if(!o.room.controller)throw new Error("Creep is full in a room without a controller");const a=o.room.find(FIND_MY_SPAWNS,{filter:t=>t.store.getFreeCapacity(RESOURCE_ENERGY)>0});a.length?l(o,a[0].id):l(o,o.room.controller.id)}break}},E=()=>{var o;c();for(const s in Game.rooms){const e=Game.rooms[s];e.memory.tasks||(e.memory.tasks={}),k(e);const a=(o=i[s])!=null?o:[];for(const t of a)if(t.memory.task||d(t),t.memory.task){const n=Game.getObjectById(t.memory.task);n instanceof Source?(t.speak("Mining"),g(t,n)):n instanceof StructureStorage||n instanceof StructureController?(t.speak("Depositing"),u(t,n)):t.speak("Broken",n)}for(const t of e.find(FIND_SOURCES_ACTIVE))e.memory.tasks[t.id]||(e.memory.tasks[t.id]=[null,null,null])}};exports.loop=E;
//# sourceMappingURL=my-lib.js.map
