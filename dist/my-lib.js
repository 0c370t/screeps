"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m={},c=()=>{if(Game.time%100===0)for(const o in Memory.creeps)o in Game.creeps||delete Memory.creeps[o];for(const o in Game.creeps){const e=Game.creeps[o];if(!e.my)continue;const s=e.memory.room||e.room.name;m[s]=m[s]||[],m[s].push(e)}},f=o=>{var n,t;typeof o=="string"&&(o=Game.rooms[o]);const e=(n=m[o.name])!=null?n:[];let s=[],r="";if(e.length<3&&o.energyAvailable>=250&&(s=["work","carry","move","move"],r="basic-worker"),s.length){const i=o.find(FIND_MY_SPAWNS,{filter:a=>!a.spawning});if(i.length){const a=(t=i.pop())==null?void 0:t.spawnCreep(s,[o.name,Game.time,r].filter(Boolean).join(":"),{memory:{room:o.name,role:r}});a===OK?console.log("Spawned a screep!"):console.log("Failed to spawn a screep!",a)}}},l=(o,e)=>{if(o.memory.task){const s=o.room.memory.tasks[o.memory.task].indexOf(o.name);o.room.memory.tasks[o.memory.task][s]=null}o.memory.task=e},y=o=>{const e=Object.entries(o.room.memory.tasks).find(([r,n])=>{n.filter(Boolean).length>0});if(!e){console.log(`${o.name} is bored`);return}const s=e[1].indexOf(null);e[1][s]=o.name,o.memory.task=e[0]},k=(o,e)=>{switch(o.transfer(e,RESOURCE_ENERGY)){case ERR_NOT_IN_RANGE:o.moveTo(e);break;case OK:o.store.getUsedCapacity()===0&&l(o);break}},d=(o,e)=>{switch(o.harvest(e)){case ERR_NOT_IN_RANGE:o.moveTo(e);break;case OK:if(o.store.getFreeCapacity()===0){if(!o.room.controller)throw new Error("Creep is full in a room without a controller");l(o,o.room.controller.id)}break}},u=()=>{var o;c();for(const e in Game.rooms){const s=Game.rooms[e];s.memory.tasks||(s.memory.tasks={}),f(s);const r=(o=m[e])!=null?o:[];for(const n of r)if(n.memory.task||y(n),n.memory.task){const t=Game.getObjectById(n.memory.task);t instanceof Source?d(n,t):t instanceof StructureController&&k(n,t)}for(const n of s.find(FIND_SOURCES_ACTIVE))s.memory.tasks[n.id]||(s.memory.tasks[n.id]=[null,null,null])}};exports.loop=u;
//# sourceMappingURL=my-lib.js.map
